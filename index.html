<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CRoaring: CRoaring</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CRoaring<span id="projectnumber">&#160;4.4.1</span>
   </div>
   <div id="projectbrief">Roaring bitmaps in C (and C++)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">CRoaring </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_README"></a> <a href="https://github.com/RoaringBitmap/CRoaring/actions/workflows/ubuntu-noexcept-ci.yml"><img src="https://github.com/RoaringBitmap/CRoaring/actions/workflows/ubuntu-noexcept-ci.yml/badge.svg" alt="Ubuntu-CI" style="pointer-events: none;" class="inline"/></a> <a href="https://github.com/RoaringBitmap/CRoaring/actions/workflows/vs17-ci.yml"><img src="https://github.com/RoaringBitmap/CRoaring/actions/workflows/vs17-ci.yml/badge.svg" alt="VS17-CI" style="pointer-events: none;" class="inline"/></a> <a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?sort=-opened&amp;can=1&amp;q=proj:croaring"><img src="https://oss-fuzz-build-logs.storage.googleapis.com/badges/croaring.svg" alt="Fuzzing Status" style="pointer-events: none;" class="inline"/></a></p>
<p><a href="http://roaringbitmap.github.io/CRoaring/"><img src="https://img.shields.io/badge/docs-doxygen-green.svg" alt="Doxygen Documentation" style="pointer-events: none;" class="inline"/></a></p>
<p>Portable Roaring bitmaps in C (and C++) with full support for your favorite compiler (GNU GCC, LLVM's clang, Visual Studio, Apple Xcode, Intel oneAPI). Included in the <a href="https://github.com/kozross/awesome-c">Awesome C</a> list of open source C software.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Table of Contents</h1>
<ul>
<li>Introduction</li>
<li>Objective</li>
<li>Requirements</li>
<li>Quick Start</li>
<li>Packages</li>
<li>Using Roaring as a CPM dependency</li>
<li>Using as a CMake dependency with FetchContent</li>
<li>Amalgamating</li>
<li>API<ul>
<li>Main API functions</li>
<li>C++ API functions</li>
</ul>
</li>
<li>Dealing with large volumes of data</li>
<li>Running microbenchmarks</li>
<li>Custom memory allocators</li>
<li>Example (C)</li>
<li>Compressed 64-bit Roaring bitmaps (C)</li>
<li>Conventional bitsets (C)</li>
<li>Example (C++)</li>
<li>Building with cmake (Linux and macOS, Visual Studio users should see below)</li>
<li>Building (Visual Studio under Windows)<ul>
<li>Usage (Using conan)</li>
<li>Usage (Using vcpkg on Windows, Linux and macOS)</li>
</ul>
</li>
<li>SIMD-related throttling</li>
<li>Thread safety</li>
<li>How to best aggregate bitmaps?</li>
<li>Wrappers for Roaring Bitmaps</li>
<li>Mailing list/discussion group</li>
<li>Contributing</li>
<li>References about Roaring</li>
</ul>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>Bitsets, also called bitmaps, are commonly used as fast data structures. Unfortunately, they can use too much memory. To compensate, we often use compressed bitmaps.</p>
<p>Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. They are used by several major systems such as <a href="https://lucene.apache.org/">Apache Lucene</a> and derivative systems such as <a href="https://lucene.apache.org/solr/">Solr</a> and <a href="https://www.elastic.co/products/elasticsearch">Elasticsearch</a>, <a href="http://druid.io/">Metamarkets' Druid</a>, <a href="http://github.com/linkedin/pinot/wiki">LinkedIn Pinot</a>, <a href="https://github.com/Netflix/atlas">Netflix Atlas</a>, <a href="https://spark.apache.org/">Apache Spark</a>, <a href="http://www.opensearchserver.com">OpenSearchServer</a>, <a href="https://github.com/jpillora/cloud-torrent">Cloud Torrent</a>, <a href="https://bitbucket.org/mchaput/whoosh/wiki/Home">Whoosh</a>, <a href="https://www.influxdata.com">InfluxDB</a>, <a href="https://www.pilosa.com/">Pilosa</a>, <a href="http://www.blevesearch.com">Bleve</a>, <a href="https://www.visualstudio.com/team-services/">Microsoft Visual Studio Team Services (VSTS)</a>, and eBay's <a href="http://kylin.apache.org/">Apache Kylin</a>. The CRoaring library is used in several systems such as <a href="http://doris.incubator.apache.org">Apache Doris</a>, <a href="https://github.com/ClickHouse/ClickHouse">ClickHouse</a>, <a href="https://github.com/redpanda-data/redpanda">Redpanda</a>, <a href="https://ydb.tech">YDB</a>, <a href="https://www.alibabacloud.com/help/en/redis/developer-reference/tairroaring-command">Alibaba Tair</a>, and <a href="https://github.com/StarRocks/starrocks">StarRocks</a>. The YouTube SQL Engine, <a href="https://research.google/pubs/pub48388/">Google Procella</a>, uses Roaring bitmaps for indexing.</p>
<p>We published a peer-reviewed article on the design and evaluation of this library:</p>
<ul>
<li>Roaring Bitmaps: Implementation of an Optimized Software Library, Software: Practice and Experience 48 (4), 2018 <a href="https://arxiv.org/abs/1709.07821">arXiv:1709.07821</a></li>
</ul>
<p>Roaring bitmaps are found to work well in many important applications:</p>
<blockquote class="doxtable">
<p>&zwj;Use Roaring for bitmap compression whenever possible. Do not use other bitmap compression methods (<a href="http://db.ucsd.edu/wp-content/uploads/2017/03/sidm338-wangA.pdf">Wang et al., SIGMOD 2017</a>) </p>
</blockquote>
<p><a href="https://github.com/RoaringBitmap/RoaringFormatSpec/">There is a serialized format specification for interoperability between implementations</a>. Hence, it is possible to serialize a Roaring Bitmap from C++, read it in Java, modify it, serialize it back and read it in Go and Python.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Objective</h1>
<p>The primary goal of the CRoaring is to provide a high performance low-level implementation that fully take advantage of the latest hardware. Roaring bitmaps are already available on a variety of platform through Java, Go, Rust... implementations. CRoaring is a library that seeks to achieve superior performance by staying close to the latest hardware.</p>
<p>(c) 2016-... The CRoaring authors.</p>
<h1><a class="anchor" id="autotoc_md4"></a>
Requirements</h1>
<ul>
<li>Linux, macOS, FreeBSD, Windows (MSYS2 and Microsoft Visual studio).</li>
<li>We test the library with ARM, x64/x86 and POWER processors. We only support little endian systems (big endian systems are vanishingly rare).</li>
<li>Recent C compiler supporting the C11 standard (GCC 7 or better, LLVM 8 or better (clang), Xcode 11 or better, Microsoft Visual Studio 2022 or better, Intel oneAPI Compiler 2023.2 or better), there is also an optional C++ class that requires a C++ compiler supporting the C++11 standard.</li>
<li>CMake (to contribute to the project, users can rely on amalgamation/unity builds if they do not wish to use CMake).</li>
<li>The CMake system assumes that git is available.</li>
<li>Under x64 systems, the library provides runtime dispatch so that optimized functions are called based on the detected CPU features. It works with GCC, clang (version 9 and up) and Visual Studio (2017 and up). Other systems (e.g., ARM) do not need runtime dispatch.</li>
</ul>
<p>Hardly anyone has access to an actual big-endian system. Nevertheless, We support big-endian systems such as IBM s390x through emulators&mdash;except for IO serialization which is only supported on little-endian systems (see <a href="https://github.com/RoaringBitmap/CRoaring/issues/423">issue 423</a>).</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Quick Start</h1>
<p>The CRoaring library can be amalgamated into a single source file that makes it easier for integration into other projects. Moreover, by making it possible to compile all the critical code into one compilation unit, it can improve the performance. For the rationale, please see the <a href="https://www.sqlite.org/amalgamation.html">SQLite documentation</a>, or the corresponding <a href="https://en.wikipedia.org/wiki/Single_Compilation_Unit">Wikipedia entry</a>. Users who choose this route, do not need to rely on CRoaring's build system (based on CMake).</p>
<p>We offer amalgamated files as part of each release.</p>
<p>Linux or macOS users might follow the following instructions if they have a recent C or C++ compiler installed and a standard utility (<code>wget</code>).</p>
<ol type="1">
<li>Pull the library in a directory <code> wget <a href="https://github.com/RoaringBitmap/CRoaring/releases/download/v2.1.0/roaring.c">https://github.com/RoaringBitmap/CRoaring/releases/download/v2.1.0/roaring.c</a> wget <a href="https://github.com/RoaringBitmap/CRoaring/releases/download/v2.1.0/roaring.h">https://github.com/RoaringBitmap/CRoaring/releases/download/v2.1.0/roaring.h</a> wget <a href="https://github.com/RoaringBitmap/CRoaring/releases/download/v2.1.0/roaring.hh">https://github.com/RoaringBitmap/CRoaring/releases/download/v2.1.0/roaring.hh</a> </code></li>
<li><p class="startli">Create a new file named <code>demo.c</code> with this content: ```C #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "roaring.c" int main() { roaring_bitmap_t *r1 = <a class="el" href="dc/d56/roaring_8h.html#a02f5d67a889993b158e55d0eb79b340b">roaring_bitmap_create()</a>; for (uint32_t i = 100; i &lt; 1000; i++) roaring_bitmap_add(r1, i); printf("cardinality = %d\n", (int) roaring_bitmap_get_cardinality(r1)); roaring_bitmap_free(r1);</p>
<p class="startli">bitset_t *b = bitset_create(); for (int k = 0; k &lt; 1000; ++k) { bitset_set(b, 3 * k); } printf("%zu \n", bitset_count(b)); bitset_free(b); return EXIT_SUCCESS; } <code></code></p>
</li>
</ol>
<ol type="1">
<li><p class="startli"><code>Create a new file named `demo.cpp` with this content: </code>C++ #include &lt;iostream&gt; #include "roaring.hh" // the amalgamated roaring.hh includes roaring64map.hh #include "roaring.c" int main() { roaring::Roaring r1; for (uint32_t i = 100; i &lt; 1000; i++) { r1.add(i); } std::cout &lt;&lt; "cardinality = " &lt;&lt; r1.cardinality() &lt;&lt; std::endl;</p>
<p class="startli">roaring::Roaring64Map r2; for (uint64_t i = 18000000000000000100ull; i &lt; 18000000000000001000ull; i++) { r2.add(i); } std::cout &lt;&lt; "cardinality = " &lt;&lt; r2.cardinality() &lt;&lt; std::endl; return 0; } <code></code></p>
</li>
</ol>
<ol type="1">
<li><code>Compile </code> cc -o demo demo.c c++ -std=c++11 -o demopp demo.cpp <code></code></li>
<li><code>`./demo` </code> cardinality = 900 1000 <code></code></li>
<li><code>`./demopp` </code> cardinality = 900 cardinality = 900 ```</li>
</ol>
<h2><a class="anchor" id="autotoc_md6"></a>
Packages</h2>
<p><a href="https://repology.org/project/croaring/versions"><img src="https://repology.org/badge/vertical-allrepos/croaring.svg" alt="Packaging status" style="pointer-events: none;" class="inline"/></a></p>
<h1><a class="anchor" id="autotoc_md7"></a>
Using Roaring as a CPM dependency</h1>
<p>If you like CMake and CPM, you can add just a few lines in your <code>CMakeLists.txt</code> file to grab a <code>CRoaring</code> release. <a href="https://github.com/RoaringBitmap/CPMdemo">See our CPM demonstration for further details</a>.</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.10)</div>
<div class="line">project(roaring_demo</div>
<div class="line">  LANGUAGES CXX C</div>
<div class="line">)</div>
<div class="line">set(CMAKE_CXX_STANDARD 17)</div>
<div class="line">set(CMAKE_C_STANDARD 11)</div>
<div class="line"> </div>
<div class="line">add_executable(hello hello.cpp)</div>
<div class="line"># You can add CPM.cmake like so:</div>
<div class="line"># mkdir -p cmake</div>
<div class="line"># wget -O cmake/CPM.cmake https://github.com/cpm-cmake/CPM.cmake/releases/latest/download/get_cpm.cmake</div>
<div class="line">include(cmake/CPM.cmake)</div>
<div class="line">CPMAddPackage(</div>
<div class="line">  NAME roaring</div>
<div class="line">  GITHUB_REPOSITORY &quot;RoaringBitmap/CRoaring&quot;</div>
<div class="line">  GIT_TAG v2.0.4</div>
<div class="line">  OPTIONS &quot;ENABLE_ROARING_TESTS OFF&quot;</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">target_link_libraries(hello roaring::roaring)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Using as a CMake dependency with FetchContent</h1>
<p>If you like CMake, you can add just a few lines in your <code>CMakeLists.txt</code> file to grab a <code>CRoaring</code> release. <a href="https://github.com/RoaringBitmap/croaring_cmake_demo_single_file">See our demonstration for further details</a>.</p>
<p>If you installed the CRoaring library locally, you may use it with CMake's <code>find_package</code> function as in this example:</p>
<div class="fragment"><div class="line">cmake_minimum_required(VERSION 3.15)</div>
<div class="line"> </div>
<div class="line">project(test_roaring_install VERSION 0.1.0 LANGUAGES CXX C)</div>
<div class="line"> </div>
<div class="line">set(CMAKE_CXX_STANDARD 11)</div>
<div class="line">set(CMAKE_CXX_STANDARD_REQUIRED ON)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">set(CMAKE_C_STANDARD 11)</div>
<div class="line">set(CMAKE_C_STANDARD_REQUIRED ON)</div>
<div class="line"> </div>
<div class="line">find_package(roaring REQUIRED)</div>
<div class="line"> </div>
<div class="line">file(WRITE main.cpp &quot;</div>
<div class="line">#include &lt;iostream&gt;</div>
<div class="line">#include \&quot;roaring/roaring.hh\&quot;</div>
<div class="line">int main() {</div>
<div class="line">  roaring::Roaring r1;</div>
<div class="line">  for (uint32_t i = 100; i &lt; 1000; i++) {</div>
<div class="line">    r1.add(i);</div>
<div class="line">  }</div>
<div class="line">  std::cout &lt;&lt; \&quot;cardinality = \&quot; &lt;&lt; r1.cardinality() &lt;&lt; std::endl;</div>
<div class="line">  return 0;</div>
<div class="line">}&quot;)</div>
<div class="line"> </div>
<div class="line">add_executable(repro main.cpp)</div>
<div class="line">target_link_libraries(repro PUBLIC roaring::roaring)</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md9"></a>
Amalgamating</h1>
<p>To generate the amalgamated files yourself, you can invoke a bash script...</p>
<div class="fragment"><div class="line">./amalgamation.sh</div>
</div><!-- fragment --><p>If you prefer a silent output, you can use the following command to redirect <code>stdout</code> :</p>
<div class="fragment"><div class="line">./amalgamation.sh &gt; /dev/null</div>
</div><!-- fragment --><p>(Bash shells are standard under Linux and macOS. Bash shells are available under Windows as part of the  <a href="https://desktop.github.com/">GitHub Desktop</a> under the name <code>Git Shell</code>. So if you have cloned the <code>CRoaring</code> GitHub repository from within the GitHub Desktop, you can right-click on <code>CRoaring</code>, select <code>Git Shell</code> and then enter the above commands.)</p>
<p>It is not necessary to invoke the script in the CRoaring directory. You can invoke it from any directory where you want the amalgamation files to be written.</p>
<p>It will generate three files for C users: <code><a class="el" href="dc/d56/roaring_8h.html">roaring.h</a></code>, <code>roaring.c</code> and <code>amalgamation_demo.c</code>... as well as some brief instructions. The <code>amalgamation_demo.c</code> file is a short example, whereas <code><a class="el" href="dc/d56/roaring_8h.html">roaring.h</a></code> and <code>roaring.c</code> are "amalgamated" files (including all source and header files for the project). This means that you can simply copy the files <code><a class="el" href="dc/d56/roaring_8h.html">roaring.h</a></code> and <code>roaring.c</code> into your project and be ready to go! No need to produce a library! See the <code>amalgamation_demo.c</code> file.</p>
<h1><a class="anchor" id="autotoc_md10"></a>
API</h1>
<p>The C interface is found in the files</p>
<ul>
<li><a href="https://github.com/RoaringBitmap/CRoaring/blob/master/include/roaring/roaring.h">roaring.h</a>,</li>
<li><a href="https://github.com/RoaringBitmap/CRoaring/blob/master/include/roaring/roaring64.h">roaring64.h</a>.</li>
</ul>
<p>We also have a C++ interface:</p>
<ul>
<li><a href="https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring/roaring.hh">roaring.hh</a>,</li>
<li><a href="https://github.com/RoaringBitmap/CRoaring/blob/master/cpp/roaring/roaring64map.hh">roaring64map.hh</a>.</li>
</ul>
<h1><a class="anchor" id="autotoc_md11"></a>
Main API functions</h1>
<p>Below is an overview of the main functions provided by CRoaring in C, covering both 32-bit (<code><a class="el" href="dc/d56/roaring_8h.html">roaring.h</a></code>) and 64-bit (<code><a class="el" href="d8/d01/roaring64_8h.html">roaring64.h</a></code>) bitmaps. For more details, see the header files in <code>include/roaring/</code> or the Doxygen documentation.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Creation and Destruction</h2>
<ul>
<li><code>roaring_bitmap_t *roaring_bitmap_create(void);</code> <br  />
 Create a new empty 32-bit bitmap.</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_create(void);</code> <br  />
 Create a new empty 64-bit bitmap.</li>
<li><code>void roaring_bitmap_free(roaring_bitmap_t *r);</code> <br  />
 Free a 32-bit bitmap.</li>
<li><code>void <a class="el" href="d8/d01/roaring64_8h.html#aef1d257f0919f000eee69813b5484986">roaring64_bitmap_free(roaring64_bitmap_t *r)</a>;</code> <br  />
 Free a 64-bit bitmap.</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Adding and Removing Values</h2>
<ul>
<li><code>void <a class="el" href="dc/d56/roaring_8h.html#af85d814ca8a6cd369905f629922c1c98">roaring_bitmap_add(roaring_bitmap_t *r, uint32_t x)</a>;</code> <br  />
 Add value <code>x</code> to a 32-bit bitmap.</li>
<li><code>void <a class="el" href="d8/d01/roaring64_8h.html#a511b38d167a3c0f4ddfbd5c8ca7b6f19">roaring64_bitmap_add(roaring64_bitmap_t *r, uint64_t x)</a>;</code> <br  />
 Add value <code>x</code> to a 64-bit bitmap.</li>
<li><code>void <a class="el" href="dc/d56/roaring_8h.html#a7d8cab9c84f67c8deed8836a8eef712b">roaring_bitmap_remove(roaring_bitmap_t *r, uint32_t x)</a>;</code> <br  />
 Remove value <code>x</code> from a 32-bit bitmap.</li>
<li><code>void <a class="el" href="d8/d01/roaring64_8h.html#a101086533f5a251a64e596b97fea1ea0">roaring64_bitmap_remove(roaring64_bitmap_t *r, uint64_t x)</a>;</code> <br  />
 Remove value <code>x</code> from a 64-bit bitmap.</li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Queries and Cardinality</h2>
<ul>
<li><code>bool <a class="el" href="dc/d56/roaring_8h.html#a7c1d6efba899e68a68d436cb9db62964">roaring_bitmap_contains(const roaring_bitmap_t *r, uint32_t x)</a>;</code> <br  />
 Check if <code>x</code> is present in a 32-bit bitmap.</li>
<li><code>bool <a class="el" href="d8/d01/roaring64_8h.html#a9936db4cd41d8ff0797cbb08f8441e15">roaring64_bitmap_contains(const roaring64_bitmap_t *r, uint64_t x)</a>;</code> <br  />
 Check if <code>x</code> is present in a 64-bit bitmap.</li>
<li><code>uint64_t <a class="el" href="dc/d56/roaring_8h.html#abf071a021966c2eb8da4473a9dabaad6">roaring_bitmap_get_cardinality(const roaring_bitmap_t *r)</a>;</code> <br  />
 Get the number of elements in a 32-bit bitmap.</li>
<li><code>uint64_t <a class="el" href="d8/d01/roaring64_8h.html#af1c9e7991db9341d1b3da6989395e444">roaring64_bitmap_get_cardinality(const roaring64_bitmap_t *r)</a>;</code> <br  />
 Get the number of elements in a 64-bit bitmap.</li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Iteration</h2>
<ul>
<li><code>bool <a class="el" href="dc/d56/roaring_8h.html#a5ea3f16e31066414ae7f3d0526030781">roaring_iterate(const roaring_bitmap_t *r, roaring_iterator iterator, void *param)</a>;</code> <br  />
 Iterate over all values in a 32-bit bitmap, calling <code>iterator</code> for each value.</li>
<li><code>bool roaring64_iterate(const roaring64_bitmap_t *r, roaring_iterator64 iterator, void *param);</code> <br  />
 Iterate over all values in a 64-bit bitmap.</li>
</ul>
<h2><a class="anchor" id="autotoc_md16"></a>
Set Operations</h2>
<ul>
<li><code>roaring_bitmap_t *roaring_bitmap_and(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2);</code> <br  />
 Intersection (AND) of two 32-bit bitmaps.</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_and(const roaring64_bitmap_t *r1, const roaring64_bitmap_t *r2);</code> <br  />
 Intersection (AND) of two 64-bit bitmaps.</li>
<li><code>roaring_bitmap_t *roaring_bitmap_or(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2);</code> <br  />
 Union (OR) of two 32-bit bitmaps.</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_or(const roaring64_bitmap_t *r1, const roaring64_bitmap_t *r2);</code> <br  />
 Union (OR) of two 64-bit bitmaps.</li>
<li><code>roaring_bitmap_t *roaring_bitmap_xor(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2);</code> <br  />
 Symmetric difference (XOR) of two 32-bit bitmaps.</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_xor(const roaring64_bitmap_t *r1, const roaring64_bitmap_t *r2);</code> <br  />
 Symmetric difference (XOR) of two 64-bit bitmaps.</li>
<li><code>roaring_bitmap_t *roaring_bitmap_andnot(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2);</code> <br  />
 Difference (r1 \ r2) for 32-bit bitmaps.</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_andnot(const roaring64_bitmap_t *r1, const roaring64_bitmap_t *r2);</code> <br  />
 Difference (r1 \ r2) for 64-bit bitmaps.</li>
</ul>
<h2><a class="anchor" id="autotoc_md17"></a>
Serialization and Deserialization</h2>
<ul>
<li><code>size_t <a class="el" href="dc/d56/roaring_8h.html#a9e01791b047756c2e31f27b58531968c">roaring_bitmap_portable_size_in_bytes(const roaring_bitmap_t *r)</a>;</code> <br  />
 Get the number of bytes required to serialize a 32-bit bitmap.</li>
<li><code>size_t <a class="el" href="d8/d01/roaring64_8h.html#a4cfc07eb94b1bff0df81dd0a2ff01090">roaring64_bitmap_portable_size_in_bytes(const roaring64_bitmap_t *r)</a>;</code> <br  />
 Get the number of bytes required to serialize a 64-bit bitmap.</li>
<li><code>size_t <a class="el" href="dc/d56/roaring_8h.html#a14ca6fb130b35a5497f2b1e463bda66d">roaring_bitmap_portable_serialize(const roaring_bitmap_t *r, char *buf)</a>;</code> <br  />
 Serialize a 32-bit bitmap to a buffer (portable format).</li>
<li><code>size_t <a class="el" href="d8/d01/roaring64_8h.html#a984d439666b29ff9474f89d712307d2d">roaring64_bitmap_portable_serialize(const roaring64_bitmap_t *r, char *buf)</a>;</code> <br  />
 Serialize a 64-bit bitmap to a buffer (portable format).</li>
<li><code>roaring_bitmap_t *roaring_bitmap_portable_deserialize(const char *buf);</code> <br  />
 Deserialize a 32-bit bitmap from a buffer.</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_portable_deserialize(const char *buf);</code> <br  />
 Deserialize a 64-bit bitmap from a buffer.</li>
<li><code>roaring_bitmap_t *roaring_bitmap_portable_deserialize_safe(const char *buf, size_t maxbytes);</code> <br  />
 Safe deserialization of a 32-bit bitmap (will not read past <code>maxbytes</code>).</li>
<li><code>roaring64_bitmap_t *roaring64_bitmap_portable_deserialize_safe(const char *buf, size_t maxbytes);</code> <br  />
 Safe deserialization of a 64-bit bitmap.</li>
<li><code>size_t <a class="el" href="dc/d56/roaring_8h.html#a1136ca5cea06c428356cd24a8c423a74">roaring_bitmap_portable_deserialize_size(const char *buf, size_t maxbytes)</a>;</code> <br  />
 Get the size of a serialized 32-bit bitmap (returns 0 if invalid).</li>
<li><code>size_t <a class="el" href="d8/d01/roaring64_8h.html#a9a5113340fea367d4f4b265843faaf75">roaring64_bitmap_portable_deserialize_size(const char *buf, size_t maxbytes)</a>;</code> <br  />
 Get the size of a serialized 64-bit bitmap (returns 0 if invalid).</li>
</ul>
<h2><a class="anchor" id="autotoc_md18"></a>
Validation</h2>
<ul>
<li><code>bool <a class="el" href="dc/d56/roaring_8h.html#a2b6a2da78ef1345086afe070f6831db3">roaring_bitmap_internal_validate(const roaring_bitmap_t *r, const char **reason)</a>;</code> <br  />
 Validate the internal structure of a 32-bit bitmap. Returns <code>true</code> if valid, <code>false</code> otherwise. If invalid, <code>reason</code> points to a string describing the problem.</li>
<li><code>bool <a class="el" href="d8/d01/roaring64_8h.html#a7f02299fe0d771e770b81dc8e936ba77">roaring64_bitmap_internal_validate(const roaring64_bitmap_t *r, const char **reason)</a>;</code> <br  />
 Validate the internal structure of a 64-bit bitmap.</li>
</ul>
<h2><a class="anchor" id="autotoc_md19"></a>
Notes</h2>
<ul>
<li>All memory allocated by the library must be freed using the corresponding <code>free</code> function.</li>
<li>The portable serialization format is cross-platform and can be shared between different languages and architectures.</li>
<li>Always validate bitmaps deserialized from untrusted sources before using them.</li>
</ul>
<h1><a class="anchor" id="autotoc_md20"></a>
C++ API functions</h1>
<p>The C++ interface is provided via the <code>roaring.hh</code> (32-bit) and <code>roaring64map.hh</code> (64-bit) headers. These offer a modern, type-safe, and convenient API for manipulating Roaring bitmaps in C++.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Main Classes</h2>
<ul>
<li><code>roaring::Roaring</code> — 32-bit Roaring bitmap</li>
<li><code>roaring::Roaring64Map</code> — 64-bit Roaring bitmap</li>
</ul>
<h2><a class="anchor" id="autotoc_md22"></a>
Common Methods (32-bit and 64-bit)</h2>
<ul>
<li><code>Roaring()</code> / <code>Roaring64Map()</code><ul>
<li>Construct an empty bitmap.</li>
</ul>
</li>
<li><code>Roaring(std::initializer_list&lt;uint32_t&gt; values)</code><ul>
<li>Construct from a list of values.</li>
</ul>
</li>
<li><code>void add(uint32_t x)</code> / <code>void add(uint64_t x)</code><ul>
<li>Add a value to the bitmap.</li>
</ul>
</li>
<li><code>void remove(uint32_t x)</code> / <code>void remove(uint64_t x)</code><ul>
<li>Remove a value from the bitmap.</li>
</ul>
</li>
<li><code>bool contains(uint32_t x) const</code> / <code>bool contains(uint64_t x) const</code><ul>
<li>Check if a value is present.</li>
</ul>
</li>
<li><code>uint64_t cardinality() const</code><ul>
<li>Get the number of elements in the bitmap.</li>
</ul>
</li>
<li><code>bool isEmpty() const</code><ul>
<li>Check if the bitmap is empty.</li>
</ul>
</li>
<li><code>void clear()</code><ul>
<li>Remove all elements.</li>
</ul>
</li>
<li><code>void runOptimize()</code><ul>
<li>Convert internal containers to run containers for better compression.</li>
</ul>
</li>
<li><code>void setCopyOnWrite(bool enable)</code><ul>
<li>Enable or disable copy-on-write mode for fast/shallow copies.</li>
</ul>
</li>
<li><code>bool operator==(const Roaring&amp;) const</code> / <code>bool operator==(const Roaring64Map&amp;) const</code><ul>
<li>Equality comparison.</li>
</ul>
</li>
<li><code>void swap(Roaring&amp;)</code> / <code>void swap(Roaring64Map&amp;)</code><ul>
<li>Swap contents with another bitmap.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md23"></a>
Set Operations</h2>
<ul>
<li><code>Roaring operator|(const Roaring&amp;) const</code> / <code>Roaring64Map operator|(const Roaring64Map&amp;) const</code><ul>
<li>Union (OR)</li>
</ul>
</li>
<li><code>Roaring operator&amp;(const Roaring&amp;) const</code> / <code>Roaring64Map operator&amp;(const Roaring64Map&amp;) const</code><ul>
<li>Intersection (AND)</li>
</ul>
</li>
<li><code>Roaring operator^(const Roaring&amp;) const</code> / <code>Roaring64Map operator^(const Roaring64Map&amp;) const</code><ul>
<li>Symmetric difference (XOR)</li>
</ul>
</li>
<li><code>Roaring operator-(const Roaring&amp;) const</code> / <code>Roaring64Map operator-(const Roaring64Map&amp;) const</code><ul>
<li>Difference</li>
</ul>
</li>
<li>In-place versions: <code>operator|=</code>, <code>operator&amp;=</code>, <code>operator^=</code>, <code>operator-=</code></li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
Iteration</h2>
<ul>
<li><code>Roaring::const_iterator</code> / <code>Roaring64Map::const_iterator</code><ul>
<li>Standard C++ iterator support: <code>begin()</code>, <code>end()</code></li>
</ul>
</li>
<li><code>void iterate(function, void* param)</code><ul>
<li>Call a function for each value (C-style callback).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md25"></a>
Serialization and Deserialization</h2>
<ul>
<li><code>size_t getSizeInBytes() const</code><ul>
<li>Get the size in bytes for serialization.</li>
</ul>
</li>
<li><code>void write(char* buf) const</code><ul>
<li>Serialize the bitmap to a buffer.</li>
</ul>
</li>
<li><code>static Roaring read(const char* buf, bool portable = true)</code><ul>
<li>Deserialize a bitmap from a buffer.</li>
</ul>
</li>
<li><code>static Roaring readSafe(const char* buf, size_t maxbytes, bool portable = true)</code><ul>
<li>Safe deserialization (will not read past <code>maxbytes</code>).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
Bulk Operations</h2>
<ul>
<li><code>void addMany(size_t n, const uint32_t* values)</code> / <code>void addMany(size_t n, const uint64_t* values)</code><ul>
<li>Add many values at once.</li>
</ul>
</li>
<li><code>void toUint32Array(uint32_t* out) const</code> / <code>void toUint64Array(uint64_t* out) const</code><ul>
<li>Export all values to an array.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
Example Usage</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;roaring/roaring.hh&quot;</span></div>
<div class="line"><span class="keyword">using namespace </span>roaring;</div>
<div class="line"> </div>
<div class="line">Roaring r1;</div>
<div class="line">r1.add(42);</div>
<div class="line"><span class="keywordflow">if</span> (r1.contains(42)) {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line">Roaring r2 = Roaring::bitmapOf(3, 1, 2, 3);</div>
<div class="line">Roaring r3 = r1 | r2;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> v : r3) {</div>
<div class="line">    <span class="comment">// iterate over values</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>For 64-bit values, use <code>#include "roaring64map.hh"</code> and the <code>Roaring64Map</code> class, which has a similar API.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Dealing with large volumes of data</h1>
<p>Some users have to deal with large volumes of data. It may be important for these users to be aware of the <code>addMany</code> (C++) <code>roaring_bitmap_or_many</code> (C) functions as it is much faster and economical to add values in batches when possible. Furthermore, calling periodically the <code>runOptimize</code> (C++) or <code>roaring_bitmap_run_optimize</code> (C) functions may help.</p>
<h1><a class="anchor" id="autotoc_md29"></a>
Running microbenchmarks</h1>
<p>We have microbenchmarks constructed with the Google Benchmarks. Under Linux or macOS, you may run them as follows:</p>
<div class="fragment"><div class="line">cmake -B build -D ENABLE_ROARING_MICROBENCHMARKS=ON</div>
<div class="line">cmake --build build</div>
<div class="line">./build/microbenchmarks/bench</div>
</div><!-- fragment --><p>By default, the benchmark tools picks one data set (e.g., <code>CRoaring/benchmarks/realdata/census1881</code>). We have several data sets and you may pick others:</p>
<div class="fragment"><div class="line">./build/microbenchmarks/bench benchmarks/realdata/wikileaks-noquotes</div>
</div><!-- fragment --><p>You may disable some functionality for the purpose of benchmarking. For example, assuming you have an x64 processor, you could benchmark the code without AVX-512 even if both your processor and compiler supports it:</p>
<div class="fragment"><div class="line">cmake -B buildnoavx512 -D ROARING_DISABLE_AVX512=ON -D ENABLE_ROARING_MICROBENCHMARKS=ON</div>
<div class="line">cmake --build buildnoavx512</div>
<div class="line">./buildnoavx512/microbenchmarks/bench</div>
</div><!-- fragment --><p>You can benchmark without AVX or AVX-512 as well:</p>
<div class="fragment"><div class="line">cmake -B buildnoavx -D ROARING_DISABLE_AVX=ON -D ENABLE_ROARING_MICROBENCHMARKS=ON</div>
<div class="line">cmake --build buildnoavx</div>
<div class="line">./buildnoavx/microbenchmarks/bench</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md30"></a>
Custom memory allocators</h1>
<p>For general users, CRoaring would apply default allocator without extra codes. But global memory hook is also provided for those who want a custom memory allocator. Here is an example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dc/d56/roaring_8h.html">roaring.h</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main(){</div>
<div class="line">    <span class="comment">// define with your own memory hook</span></div>
<div class="line">    roaring_memory_t my_hook{my_malloc, my_free ...};</div>
<div class="line">    <span class="comment">// initialize global memory hook</span></div>
<div class="line">    roaring_init_memory_hook(my_hook);</div>
<div class="line">    <span class="comment">// write you code here</span></div>
<div class="line">    ...</div>
<div class="line">}</div>
<div class="ttc" id="aroaring_8h_html"><div class="ttname"><a href="dc/d56/roaring_8h.html">roaring.h</a></div></div>
</div><!-- fragment --><p>By default we use: </p><div class="fragment"><div class="line"><span class="keyword">static</span> roaring_memory_t global_memory_hook = {</div>
<div class="line">    .malloc = malloc,</div>
<div class="line">    .realloc = realloc,</div>
<div class="line">    .calloc = calloc,</div>
<div class="line">    .free = free,</div>
<div class="line">    .aligned_malloc = roaring_bitmap_aligned_malloc,</div>
<div class="line">    .aligned_free = roaring_bitmap_aligned_free,</div>
<div class="line">};</div>
</div><!-- fragment --><p>We require that the <code>free</code>/<code>aligned_free</code> functions follow the C convention where <code>free(NULL)</code>/<code>aligned_free(NULL)</code> have no effect.</p>
<h1><a class="anchor" id="autotoc_md31"></a>
Example (C)</h1>
<p>This example assumes that CRoaring has been build and that you are linking against the corresponding library. By default, CRoaring will install its header files in a <code>roaring</code> directory. If you are working from the amalgamation script, you may add the line <code>#include "roaring.c"</code> if you are not linking against a prebuilt CRoaring library and replace <code>#include &lt;<a class="el" href="dc/d56/roaring_8h.html">roaring/roaring.h</a>&gt;</code> by <code>#include "roaring.h"</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dc/d56/roaring_8h.html">roaring/roaring.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> roaring_iterator_sumall(uint32_t value, <span class="keywordtype">void</span> *param) {</div>
<div class="line">    *(uint32_t *)param += value;</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// iterate till the end</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// create a new empty bitmap</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *r1 = <a class="code hl_function" href="dc/d56/roaring_8h.html#a02f5d67a889993b158e55d0eb79b340b">roaring_bitmap_create</a>();</div>
<div class="line">    <span class="comment">// then we can add values</span></div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 100; i &lt; 1000; i++) <a class="code hl_function" href="dc/d56/roaring_8h.html#af85d814ca8a6cd369905f629922c1c98">roaring_bitmap_add</a>(r1, i);</div>
<div class="line">    <span class="comment">// check whether a value is contained</span></div>
<div class="line">    assert(<a class="code hl_function" href="dc/d56/roaring_8h.html#a7c1d6efba899e68a68d436cb9db62964">roaring_bitmap_contains</a>(r1, 500));</div>
<div class="line">    <span class="comment">// compute how many bits there are:</span></div>
<div class="line">    uint32_t cardinality = <a class="code hl_function" href="dc/d56/roaring_8h.html#abf071a021966c2eb8da4473a9dabaad6">roaring_bitmap_get_cardinality</a>(r1);</div>
<div class="line">    printf(<span class="stringliteral">&quot;Cardinality = %d \n&quot;</span>, cardinality);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if your bitmaps have long runs, you can compress them by calling</span></div>
<div class="line">    <span class="comment">// run_optimize</span></div>
<div class="line">    uint32_t expectedsizebasic = <a class="code hl_function" href="dc/d56/roaring_8h.html#a9e01791b047756c2e31f27b58531968c">roaring_bitmap_portable_size_in_bytes</a>(r1);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a3a71a1bef6c0233c93caabfd8db22c2a">roaring_bitmap_run_optimize</a>(r1);</div>
<div class="line">    uint32_t expectedsizerun = <a class="code hl_function" href="dc/d56/roaring_8h.html#a9e01791b047756c2e31f27b58531968c">roaring_bitmap_portable_size_in_bytes</a>(r1);</div>
<div class="line">    printf(<span class="stringliteral">&quot;size before run optimize %d bytes, and after %d bytes\n&quot;</span>,</div>
<div class="line">           expectedsizebasic, expectedsizerun);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a new bitmap containing the values {1,2,3,5,6}</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *r2 = <a class="code hl_define" href="dc/d56/roaring_8h.html#adfb882359d1d5219449bdb40ef5e67e4">roaring_bitmap_from</a>(1, 2, 3, 5, 6);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#aeb2bce70178e0d7ba0096eb96beed660">roaring_bitmap_printf</a>(r2);  <span class="comment">// print it</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can also create a bitmap from a pointer to 32-bit integers</span></div>
<div class="line">    uint32_t somevalues[] = {2, 3, 4};</div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *r3 = <a class="code hl_function" href="dc/d56/roaring_8h.html#af6611d4a7cb36e597353ce944104e3f6">roaring_bitmap_of_ptr</a>(3, somevalues);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can also go in reverse and go from arrays to bitmaps</span></div>
<div class="line">    uint64_t card1 = <a class="code hl_function" href="dc/d56/roaring_8h.html#abf071a021966c2eb8da4473a9dabaad6">roaring_bitmap_get_cardinality</a>(r1);</div>
<div class="line">    uint32_t *arr1 = (uint32_t *)malloc(card1 * <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line">    assert(arr1 != NULL);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a4b15efab08a78a20645a96d9a69ad587">roaring_bitmap_to_uint32_array</a>(r1, arr1);</div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *r1f = <a class="code hl_function" href="dc/d56/roaring_8h.html#af6611d4a7cb36e597353ce944104e3f6">roaring_bitmap_of_ptr</a>(card1, arr1);</div>
<div class="line">    free(arr1);</div>
<div class="line">    assert(<a class="code hl_function" href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a>(r1, r1f));  <span class="comment">// what we recover is equal</span></div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(r1f);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can go from arrays to bitmaps from &quot;offset&quot; by &quot;limit&quot;</span></div>
<div class="line">    <span class="keywordtype">size_t</span> offset = 100;</div>
<div class="line">    <span class="keywordtype">size_t</span> limit = 1000;</div>
<div class="line">    uint32_t *arr3 = (uint32_t *)malloc(limit * <span class="keyword">sizeof</span>(uint32_t));</div>
<div class="line">    assert(arr3 != NULL);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a48b73721e801bee831cb7b2872cf0a29">roaring_bitmap_range_uint32_array</a>(r1, offset, limit, arr3);</div>
<div class="line">    free(arr3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can copy and compare bitmaps</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *z = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r3);</div>
<div class="line">    assert(<a class="code hl_function" href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a>(r3, z));  <span class="comment">// what we recover is equal</span></div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(z);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can compute union two-by-two</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *r1_2_3 = <a class="code hl_function" href="dc/d56/roaring_8h.html#a773dbf96c1baedeba4d2c073e3e33ebe">roaring_bitmap_or</a>(r1, r2);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#aa76a1e1fb5d1dcf88931aa7cd3961d1f">roaring_bitmap_or_inplace</a>(r1_2_3, r3);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can compute a big union</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *allmybitmaps[] = {r1, r2, r3};</div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *bigunion = <a class="code hl_function" href="dc/d56/roaring_8h.html#a4b90ef055bd16fc8d5851d96190f4e99">roaring_bitmap_or_many</a>(3, allmybitmaps);</div>
<div class="line">    assert(</div>
<div class="line">        <a class="code hl_function" href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a>(r1_2_3, bigunion));  <span class="comment">// what we recover is equal</span></div>
<div class="line">    <span class="comment">// can also do the big union with a heap</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *bigunionheap =</div>
<div class="line">        <a class="code hl_function" href="dc/d56/roaring_8h.html#a44fa6bb2413242b37966a40856db20c2">roaring_bitmap_or_many_heap</a>(3, allmybitmaps);</div>
<div class="line">    assert(<a class="code hl_function" href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a>(r1_2_3, bigunionheap));</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(r1_2_3);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(bigunion);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(bigunionheap);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can compute intersection two-by-two</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *i1_2 = <a class="code hl_function" href="dc/d56/roaring_8h.html#ab898269e29fa615e7e55439b19d91dc5">roaring_bitmap_and</a>(r1, r2);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(i1_2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can write a bitmap to a pointer and recover it later</span></div>
<div class="line">    uint32_t expectedsize = <a class="code hl_function" href="dc/d56/roaring_8h.html#a9e01791b047756c2e31f27b58531968c">roaring_bitmap_portable_size_in_bytes</a>(r1);</div>
<div class="line">    <span class="keywordtype">char</span> *serializedbytes = malloc(expectedsize);</div>
<div class="line">    <span class="comment">// When serializing data to a file, we recommend that you also use</span></div>
<div class="line">    <span class="comment">// checksums so that, at deserialization, you can be confident</span></div>
<div class="line">    <span class="comment">// that you are recovering the correct data.</span></div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a14ca6fb130b35a5497f2b1e463bda66d">roaring_bitmap_portable_serialize</a>(r1, serializedbytes);</div>
<div class="line">    <span class="comment">// Note: it is expected that the input follows the specification</span></div>
<div class="line">    <span class="comment">// https://github.com/RoaringBitmap/RoaringFormatSpec</span></div>
<div class="line">    <span class="comment">// otherwise the result may be unusable.</span></div>
<div class="line">    <span class="comment">// The &#39;roaring_bitmap_portable_deserialize_safe&#39; function will not read</span></div>
<div class="line">    <span class="comment">// beyond expectedsize bytes.</span></div>
<div class="line">    <span class="comment">// We also recommend that you use checksums to check that serialized data corresponds</span></div>
<div class="line">    <span class="comment">// to the serialized bitmap. The CRoaring library does not provide checksumming.</span></div>
<div class="line">    <a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *t = <a class="code hl_function" href="dc/d56/roaring_8h.html#a728aebc73dd5010e4041ea40d8c7faf8">roaring_bitmap_portable_deserialize_safe</a>(serializedbytes, expectedsize);</div>
<div class="line">    <span class="keywordflow">if</span>(t == NULL) { <span class="keywordflow">return</span> EXIT_FAILURE; }</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *reason = NULL;</div>
<div class="line">    <span class="comment">// If your input came from an untrusted source, then you need to validate the</span></div>
<div class="line">    <span class="comment">// resulting bitmap. Failing to do so could lead to undefined behavior, crashes and so forth.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="dc/d56/roaring_8h.html#a2b6a2da78ef1345086afe070f6831db3">roaring_bitmap_internal_validate</a>(t, &amp;reason)) {</div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// At this point, the bitmap is safe.</span></div>
<div class="line">    assert(<a class="code hl_function" href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a>(r1, t));  <span class="comment">// what we recover is equal</span></div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(t);</div>
<div class="line">    <span class="comment">// we can also check whether there is a bitmap at a memory location without</span></div>
<div class="line">    <span class="comment">// reading it</span></div>
<div class="line">    <span class="keywordtype">size_t</span> sizeofbitmap =</div>
<div class="line">        <a class="code hl_function" href="dc/d56/roaring_8h.html#a1136ca5cea06c428356cd24a8c423a74">roaring_bitmap_portable_deserialize_size</a>(serializedbytes, expectedsize);</div>
<div class="line">    assert(sizeofbitmap ==</div>
<div class="line">           expectedsize);  <span class="comment">// sizeofbitmap would be zero if no bitmap were found</span></div>
<div class="line">    <span class="comment">// We can also read the bitmap &quot;safely&quot; by specifying a byte size limit.</span></div>
<div class="line">    <span class="comment">// The &#39;roaring_bitmap_portable_deserialize_safe&#39; function will not read</span></div>
<div class="line">    <span class="comment">// beyond expectedsize bytes.</span></div>
<div class="line">    <span class="comment">// We also recommend that you use checksums to check that serialized data corresponds</span></div>
<div class="line">    <span class="comment">// to the serialized bitmap. The CRoaring library does not provide checksumming.</span></div>
<div class="line">    t = <a class="code hl_function" href="dc/d56/roaring_8h.html#a728aebc73dd5010e4041ea40d8c7faf8">roaring_bitmap_portable_deserialize_safe</a>(serializedbytes, expectedsize);</div>
<div class="line">    <span class="keywordflow">if</span>(t == NULL) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;Problem during deserialization.\n&quot;</span>);</div>
<div class="line">        <span class="comment">// We could clear any memory and close any file here.</span></div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// We can validate the bitmap we recovered to make sure it is proper.</span></div>
<div class="line">    <span class="comment">// If the data came from an untrusted source, you should call</span></div>
<div class="line">    <span class="comment">// roaring_bitmap_internal_validate.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *reason_failure = NULL;</div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code hl_function" href="dc/d56/roaring_8h.html#a2b6a2da78ef1345086afe070f6831db3">roaring_bitmap_internal_validate</a>(t, &amp;reason_failure)) {</div>
<div class="line">        printf(<span class="stringliteral">&quot;safely deserialized invalid bitmap: %s\n&quot;</span>, reason_failure);</div>
<div class="line">        <span class="comment">// We could clear any memory and close any file here.</span></div>
<div class="line">        <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">    }</div>
<div class="line">    assert(<a class="code hl_function" href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a>(r1, t));  <span class="comment">// what we recover is equal</span></div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(t);</div>
<div class="line"> </div>
<div class="line">    free(serializedbytes);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can iterate over all values using custom functions</span></div>
<div class="line">    uint32_t counter = 0;</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a5ea3f16e31066414ae7f3d0526030781">roaring_iterate</a>(r1, roaring_iterator_sumall, &amp;counter);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can also create iterator structs</span></div>
<div class="line">    counter = 0;</div>
<div class="line">    <a class="code hl_struct" href="da/d27/structroaring__uint32__iterator__s.html">roaring_uint32_iterator_t</a> *i = <a class="code hl_function" href="dc/d56/roaring_8h.html#a6411fc557537acffd5d584b29f76e5ab">roaring_iterator_create</a>(r1);</div>
<div class="line">    <span class="keywordflow">while</span> (i-&gt;<a class="code hl_variable" href="da/d27/structroaring__uint32__iterator__s.html#a99e95f8cbd08320c6ac27b1569ca6bb4">has_value</a>) {</div>
<div class="line">        counter++;  <span class="comment">// could use    i-&gt;current_value</span></div>
<div class="line">        <a class="code hl_function" href="dc/d56/roaring_8h.html#aec401e111190871fb95faaa0e4d66757">roaring_uint32_iterator_advance</a>(i);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// you can skip over values and move the iterator with</span></div>
<div class="line">    <span class="comment">// roaring_uint32_iterator_move_equalorlarger(i,someintvalue)</span></div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#aa879e686552e794ad36d33a9eedece3c">roaring_uint32_iterator_free</a>(i);</div>
<div class="line">    <span class="comment">// roaring_bitmap_get_cardinality(r1) == counter</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// for greater speed, you can iterate over the data in bulk</span></div>
<div class="line">    i = <a class="code hl_function" href="dc/d56/roaring_8h.html#a6411fc557537acffd5d584b29f76e5ab">roaring_iterator_create</a>(r1);</div>
<div class="line">    uint32_t buffer[256];</div>
<div class="line">    <span class="keywordflow">while</span> (1) {</div>
<div class="line">        uint32_t ret = <a class="code hl_function" href="dc/d56/roaring_8h.html#aa7d6e6919e46905bf7e5ddd824f3eb55">roaring_uint32_iterator_read</a>(i, buffer, 256);</div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t j = 0; j &lt; ret; j++) {</div>
<div class="line">            counter += buffer[j];</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">if</span> (ret &lt; 256) {</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#aa879e686552e794ad36d33a9eedece3c">roaring_uint32_iterator_free</a>(i);</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(r1);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(r2);</div>
<div class="line">    <a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(r3);</div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
<div class="ttc" id="aroaring_8h_html_a02f5d67a889993b158e55d0eb79b340b"><div class="ttname"><a href="dc/d56/roaring_8h.html#a02f5d67a889993b158e55d0eb79b340b">roaring_bitmap_create</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_create(void)</div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l00043">roaring.h:43</a></div></div>
<div class="ttc" id="aroaring_8h_html_a1136ca5cea06c428356cd24a8c423a74"><div class="ttname"><a href="dc/d56/roaring_8h.html#a1136ca5cea06c428356cd24a8c423a74">roaring_bitmap_portable_deserialize_size</a></div><div class="ttdeci">size_t roaring_bitmap_portable_deserialize_size(const char *buf, size_t maxbytes)</div></div>
<div class="ttc" id="aroaring_8h_html_a14ca6fb130b35a5497f2b1e463bda66d"><div class="ttname"><a href="dc/d56/roaring_8h.html#a14ca6fb130b35a5497f2b1e463bda66d">roaring_bitmap_portable_serialize</a></div><div class="ttdeci">size_t roaring_bitmap_portable_serialize(const roaring_bitmap_t *r, char *buf)</div></div>
<div class="ttc" id="aroaring_8h_html_a14d2c72b7b3d0fe2b8dde0764ebff7fd"><div class="ttname"><a href="dc/d56/roaring_8h.html#a14d2c72b7b3d0fe2b8dde0764ebff7fd">roaring_bitmap_equals</a></div><div class="ttdeci">bool roaring_bitmap_equals(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2)</div></div>
<div class="ttc" id="aroaring_8h_html_a2b6a2da78ef1345086afe070f6831db3"><div class="ttname"><a href="dc/d56/roaring_8h.html#a2b6a2da78ef1345086afe070f6831db3">roaring_bitmap_internal_validate</a></div><div class="ttdeci">bool roaring_bitmap_internal_validate(const roaring_bitmap_t *r, const char **reason)</div></div>
<div class="ttc" id="aroaring_8h_html_a30850dcaa92db1490643ccdf89856b27"><div class="ttname"><a href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_copy(const roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_a3a71a1bef6c0233c93caabfd8db22c2a"><div class="ttname"><a href="dc/d56/roaring_8h.html#a3a71a1bef6c0233c93caabfd8db22c2a">roaring_bitmap_run_optimize</a></div><div class="ttdeci">bool roaring_bitmap_run_optimize(roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_a44fa6bb2413242b37966a40856db20c2"><div class="ttname"><a href="dc/d56/roaring_8h.html#a44fa6bb2413242b37966a40856db20c2">roaring_bitmap_or_many_heap</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_or_many_heap(uint32_t number, const roaring_bitmap_t **rs)</div></div>
<div class="ttc" id="aroaring_8h_html_a48b73721e801bee831cb7b2872cf0a29"><div class="ttname"><a href="dc/d56/roaring_8h.html#a48b73721e801bee831cb7b2872cf0a29">roaring_bitmap_range_uint32_array</a></div><div class="ttdeci">bool roaring_bitmap_range_uint32_array(const roaring_bitmap_t *r, size_t offset, size_t limit, uint32_t *ans)</div></div>
<div class="ttc" id="aroaring_8h_html_a4b15efab08a78a20645a96d9a69ad587"><div class="ttname"><a href="dc/d56/roaring_8h.html#a4b15efab08a78a20645a96d9a69ad587">roaring_bitmap_to_uint32_array</a></div><div class="ttdeci">void roaring_bitmap_to_uint32_array(const roaring_bitmap_t *r, uint32_t *ans)</div></div>
<div class="ttc" id="aroaring_8h_html_a4b90ef055bd16fc8d5851d96190f4e99"><div class="ttname"><a href="dc/d56/roaring_8h.html#a4b90ef055bd16fc8d5851d96190f4e99">roaring_bitmap_or_many</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_or_many(size_t number, const roaring_bitmap_t **rs)</div></div>
<div class="ttc" id="aroaring_8h_html_a5ea3f16e31066414ae7f3d0526030781"><div class="ttname"><a href="dc/d56/roaring_8h.html#a5ea3f16e31066414ae7f3d0526030781">roaring_iterate</a></div><div class="ttdeci">bool roaring_iterate(const roaring_bitmap_t *r, roaring_iterator iterator, void *ptr)</div></div>
<div class="ttc" id="aroaring_8h_html_a6411fc557537acffd5d584b29f76e5ab"><div class="ttname"><a href="dc/d56/roaring_8h.html#a6411fc557537acffd5d584b29f76e5ab">roaring_iterator_create</a></div><div class="ttdeci">roaring_uint32_iterator_t * roaring_iterator_create(const roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_a728aebc73dd5010e4041ea40d8c7faf8"><div class="ttname"><a href="dc/d56/roaring_8h.html#a728aebc73dd5010e4041ea40d8c7faf8">roaring_bitmap_portable_deserialize_safe</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_portable_deserialize_safe(const char *buf, size_t maxbytes)</div></div>
<div class="ttc" id="aroaring_8h_html_a773dbf96c1baedeba4d2c073e3e33ebe"><div class="ttname"><a href="dc/d56/roaring_8h.html#a773dbf96c1baedeba4d2c073e3e33ebe">roaring_bitmap_or</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_or(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2)</div></div>
<div class="ttc" id="aroaring_8h_html_a77dba28e5abf41cbd2502b0fffc5eeeb"><div class="ttname"><a href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a></div><div class="ttdeci">void roaring_bitmap_free(const roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_a7c1d6efba899e68a68d436cb9db62964"><div class="ttname"><a href="dc/d56/roaring_8h.html#a7c1d6efba899e68a68d436cb9db62964">roaring_bitmap_contains</a></div><div class="ttdeci">bool roaring_bitmap_contains(const roaring_bitmap_t *r, uint32_t val)</div></div>
<div class="ttc" id="aroaring_8h_html_a9e01791b047756c2e31f27b58531968c"><div class="ttname"><a href="dc/d56/roaring_8h.html#a9e01791b047756c2e31f27b58531968c">roaring_bitmap_portable_size_in_bytes</a></div><div class="ttdeci">size_t roaring_bitmap_portable_size_in_bytes(const roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_aa76a1e1fb5d1dcf88931aa7cd3961d1f"><div class="ttname"><a href="dc/d56/roaring_8h.html#aa76a1e1fb5d1dcf88931aa7cd3961d1f">roaring_bitmap_or_inplace</a></div><div class="ttdeci">void roaring_bitmap_or_inplace(roaring_bitmap_t *r1, const roaring_bitmap_t *r2)</div></div>
<div class="ttc" id="aroaring_8h_html_aa7d6e6919e46905bf7e5ddd824f3eb55"><div class="ttname"><a href="dc/d56/roaring_8h.html#aa7d6e6919e46905bf7e5ddd824f3eb55">roaring_uint32_iterator_read</a></div><div class="ttdeci">uint32_t roaring_uint32_iterator_read(roaring_uint32_iterator_t *it, uint32_t *buf, uint32_t count)</div></div>
<div class="ttc" id="aroaring_8h_html_aa879e686552e794ad36d33a9eedece3c"><div class="ttname"><a href="dc/d56/roaring_8h.html#aa879e686552e794ad36d33a9eedece3c">roaring_uint32_iterator_free</a></div><div class="ttdeci">void roaring_uint32_iterator_free(roaring_uint32_iterator_t *it)</div></div>
<div class="ttc" id="aroaring_8h_html_ab898269e29fa615e7e55439b19d91dc5"><div class="ttname"><a href="dc/d56/roaring_8h.html#ab898269e29fa615e7e55439b19d91dc5">roaring_bitmap_and</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_and(const roaring_bitmap_t *r1, const roaring_bitmap_t *r2)</div></div>
<div class="ttc" id="aroaring_8h_html_abf071a021966c2eb8da4473a9dabaad6"><div class="ttname"><a href="dc/d56/roaring_8h.html#abf071a021966c2eb8da4473a9dabaad6">roaring_bitmap_get_cardinality</a></div><div class="ttdeci">uint64_t roaring_bitmap_get_cardinality(const roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_adfb882359d1d5219449bdb40ef5e67e4"><div class="ttname"><a href="dc/d56/roaring_8h.html#adfb882359d1d5219449bdb40ef5e67e4">roaring_bitmap_from</a></div><div class="ttdeci">#define roaring_bitmap_from(...)</div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l00169">roaring.h:169</a></div></div>
<div class="ttc" id="aroaring_8h_html_aeb2bce70178e0d7ba0096eb96beed660"><div class="ttname"><a href="dc/d56/roaring_8h.html#aeb2bce70178e0d7ba0096eb96beed660">roaring_bitmap_printf</a></div><div class="ttdeci">void roaring_bitmap_printf(const roaring_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring_8h_html_aec401e111190871fb95faaa0e4d66757"><div class="ttname"><a href="dc/d56/roaring_8h.html#aec401e111190871fb95faaa0e4d66757">roaring_uint32_iterator_advance</a></div><div class="ttdeci">bool roaring_uint32_iterator_advance(roaring_uint32_iterator_t *it)</div></div>
<div class="ttc" id="aroaring_8h_html_af6611d4a7cb36e597353ce944104e3f6"><div class="ttname"><a href="dc/d56/roaring_8h.html#af6611d4a7cb36e597353ce944104e3f6">roaring_bitmap_of_ptr</a></div><div class="ttdeci">roaring_bitmap_t * roaring_bitmap_of_ptr(size_t n_args, const uint32_t *vals)</div></div>
<div class="ttc" id="aroaring_8h_html_af85d814ca8a6cd369905f629922c1c98"><div class="ttname"><a href="dc/d56/roaring_8h.html#af85d814ca8a6cd369905f629922c1c98">roaring_bitmap_add</a></div><div class="ttdeci">void roaring_bitmap_add(roaring_bitmap_t *r, uint32_t x)</div></div>
<div class="ttc" id="astructroaring__bitmap__s_html"><div class="ttname"><a href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_s</a></div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l00026">roaring.h:26</a></div></div>
<div class="ttc" id="astructroaring__uint32__iterator__s_html"><div class="ttname"><a href="da/d27/structroaring__uint32__iterator__s.html">roaring_uint32_iterator_s</a></div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l01068">roaring.h:1068</a></div></div>
<div class="ttc" id="astructroaring__uint32__iterator__s_html_a99e95f8cbd08320c6ac27b1569ca6bb4"><div class="ttname"><a href="da/d27/structroaring__uint32__iterator__s.html#a99e95f8cbd08320c6ac27b1569ca6bb4">roaring_uint32_iterator_s::has_value</a></div><div class="ttdeci">bool has_value</div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l01077">roaring.h:1077</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md32"></a>
Compressed 64-bit Roaring bitmaps (C)</h1>
<p>We also support efficient 64-bit compressed bitmaps in C:</p>
<div class="fragment"><div class="line">++</div>
<div class="line"> <a class="code hl_typedef" href="d8/d01/roaring64_8h.html#a8c5f0692fea8689552a0c13013fbac8c">roaring64_bitmap_t</a> *r2 = <a class="code hl_function" href="d8/d01/roaring64_8h.html#abbf6b14f6f80caa5496dcc839a33b94f">roaring64_bitmap_create</a>();</div>
<div class="line"> <span class="keywordflow">for</span> (uint64_t i = 100; i &lt; 1000; i++) <a class="code hl_function" href="d8/d01/roaring64_8h.html#a511b38d167a3c0f4ddfbd5c8ca7b6f19">roaring64_bitmap_add</a>(r2, i);</div>
<div class="line"> printf(<span class="stringliteral">&quot;cardinality (64-bit) = %d\n&quot;</span>, (<span class="keywordtype">int</span>) <a class="code hl_function" href="d8/d01/roaring64_8h.html#af1c9e7991db9341d1b3da6989395e444">roaring64_bitmap_get_cardinality</a>(r2));</div>
<div class="line"> <a class="code hl_function" href="d8/d01/roaring64_8h.html#aef1d257f0919f000eee69813b5484986">roaring64_bitmap_free</a>(r2);</div>
<div class="ttc" id="aroaring64_8h_html_a511b38d167a3c0f4ddfbd5c8ca7b6f19"><div class="ttname"><a href="d8/d01/roaring64_8h.html#a511b38d167a3c0f4ddfbd5c8ca7b6f19">roaring64_bitmap_add</a></div><div class="ttdeci">void roaring64_bitmap_add(roaring64_bitmap_t *r, uint64_t val)</div></div>
<div class="ttc" id="aroaring64_8h_html_a8c5f0692fea8689552a0c13013fbac8c"><div class="ttname"><a href="d8/d01/roaring64_8h.html#a8c5f0692fea8689552a0c13013fbac8c">roaring64_bitmap_t</a></div><div class="ttdeci">struct roaring64_bitmap_s roaring64_bitmap_t</div><div class="ttdef"><b>Definition</b> <a href="d8/d01/roaring64_8h_source.html#l00019">roaring64.h:19</a></div></div>
<div class="ttc" id="aroaring64_8h_html_abbf6b14f6f80caa5496dcc839a33b94f"><div class="ttname"><a href="d8/d01/roaring64_8h.html#abbf6b14f6f80caa5496dcc839a33b94f">roaring64_bitmap_create</a></div><div class="ttdeci">roaring64_bitmap_t * roaring64_bitmap_create(void)</div></div>
<div class="ttc" id="aroaring64_8h_html_aef1d257f0919f000eee69813b5484986"><div class="ttname"><a href="d8/d01/roaring64_8h.html#aef1d257f0919f000eee69813b5484986">roaring64_bitmap_free</a></div><div class="ttdeci">void roaring64_bitmap_free(roaring64_bitmap_t *r)</div></div>
<div class="ttc" id="aroaring64_8h_html_af1c9e7991db9341d1b3da6989395e444"><div class="ttname"><a href="d8/d01/roaring64_8h.html#af1c9e7991db9341d1b3da6989395e444">roaring64_bitmap_get_cardinality</a></div><div class="ttdeci">uint64_t roaring64_bitmap_get_cardinality(const roaring64_bitmap_t *r)</div></div>
</div><!-- fragment --><p>The API is similar to the conventional 32-bit bitmaps. Please see the header file <code><a class="el" href="d8/d01/roaring64_8h.html">roaring64.h</a></code> (compare with <code><a class="el" href="dc/d56/roaring_8h.html">roaring.h</a></code>).</p>
<h1><a class="anchor" id="autotoc_md33"></a>
Conventional bitsets (C)</h1>
<p>We support convention bitsets (uncompressed) as part of the library.</p>
<p>Simple example:</p>
<div class="fragment"><div class="line">bitset_t * b = bitset_create();</div>
<div class="line">bitset_set(b,10);</div>
<div class="line">bitset_get(b,10);<span class="comment">// returns true</span></div>
<div class="line">bitset_free(b); <span class="comment">// frees memory</span></div>
</div><!-- fragment --><p>More advanced example:</p>
<div class="fragment"><div class="line">bitset_t *b = bitset_create();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; 1000; ++k) {</div>
<div class="line">    bitset_set(b, 3 * k);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// We have bitset_count(b) == 1000.</span></div>
<div class="line"><span class="comment">// We have bitset_get(b, 3) is true</span></div>
<div class="line"><span class="comment">// You can iterate through the values:</span></div>
<div class="line"><span class="keywordtype">size_t</span> k = 0;</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; bitset_next_set_bit(b, &amp;i); i++) {</div>
<div class="line">    <span class="comment">// You will have i == k</span></div>
<div class="line">    k += 3;</div>
<div class="line">}</div>
<div class="line"><span class="comment">// We support a wide range of operations on two bitsets such as</span></div>
<div class="line"><span class="comment">// bitset_inplace_symmetric_difference(b1,b2);</span></div>
<div class="line"><span class="comment">// bitset_inplace_symmetric_difference(b1,b2);</span></div>
<div class="line"><span class="comment">// bitset_inplace_difference(b1,b2);// should make no difference</span></div>
<div class="line"><span class="comment">// bitset_inplace_union(b1,b2);</span></div>
<div class="line"><span class="comment">// bitset_inplace_intersection(b1,b2);</span></div>
<div class="line"><span class="comment">// bitsets_disjoint</span></div>
<div class="line"><span class="comment">// bitsets_intersect</span></div>
</div><!-- fragment --><p>In some instances, you may want to convert a Roaring bitmap into a conventional (uncompressed) bitset. Indeed, bitsets have advantages such as higher query performances in some cases. The following code illustrates how you may do so:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *r1 = <a class="code hl_function" href="dc/d56/roaring_8h.html#a02f5d67a889993b158e55d0eb79b340b">roaring_bitmap_create</a>();</div>
<div class="line"><span class="keywordflow">for</span> (uint32_t i = 100; i &lt; 100000; i+= 1 + (i%5)) {</div>
<div class="line">     <a class="code hl_function" href="dc/d56/roaring_8h.html#af85d814ca8a6cd369905f629922c1c98">roaring_bitmap_add</a>(r1, i);</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (uint32_t i = 100000; i &lt; 500000; i+= 100) {</div>
<div class="line">     <a class="code hl_function" href="dc/d56/roaring_8h.html#af85d814ca8a6cd369905f629922c1c98">roaring_bitmap_add</a>(r1, i);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="dc/d56/roaring_8h.html#ab3a666ebfe5de619bd334b9ebe059d73">roaring_bitmap_add_range</a>(r1, 500000, 600000);</div>
<div class="line">bitset_t * bitset = bitset_create();</div>
<div class="line"><span class="keywordtype">bool</span> success = <a class="code hl_function" href="dc/d56/roaring_8h.html#a981ceddb33269e47cc3c61b9bf71a450">roaring_bitmap_to_bitset</a>(r1, bitset);</div>
<div class="line">assert(success); <span class="comment">// could fail due to memory allocation.</span></div>
<div class="line">assert(bitset_count(bitset) == <a class="code hl_function" href="dc/d56/roaring_8h.html#abf071a021966c2eb8da4473a9dabaad6">roaring_bitmap_get_cardinality</a>(r1));</div>
<div class="line"><span class="comment">// You can then query the bitset:</span></div>
<div class="line"><span class="keywordflow">for</span> (uint32_t i = 100; i &lt; 100000; i+= 1 + (i%5)) {</div>
<div class="line">    assert(bitset_get(bitset,i));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">for</span> (uint32_t i = 100000; i &lt; 500000; i+= 100) {</div>
<div class="line">    assert(bitset_get(bitset,i));</div>
<div class="line">}</div>
<div class="line"><span class="comment">// you must free the memory:</span></div>
<div class="line">bitset_free(bitset);</div>
<div class="line"><a class="code hl_function" href="dc/d56/roaring_8h.html#a77dba28e5abf41cbd2502b0fffc5eeeb">roaring_bitmap_free</a>(r1);</div>
<div class="ttc" id="aroaring_8h_html_a981ceddb33269e47cc3c61b9bf71a450"><div class="ttname"><a href="dc/d56/roaring_8h.html#a981ceddb33269e47cc3c61b9bf71a450">roaring_bitmap_to_bitset</a></div><div class="ttdeci">bool roaring_bitmap_to_bitset(const roaring_bitmap_t *r, bitset_t *bitset)</div></div>
<div class="ttc" id="aroaring_8h_html_ab3a666ebfe5de619bd334b9ebe059d73"><div class="ttname"><a href="dc/d56/roaring_8h.html#ab3a666ebfe5de619bd334b9ebe059d73">roaring_bitmap_add_range</a></div><div class="ttdeci">void roaring_bitmap_add_range(roaring_bitmap_t *r, uint64_t min, uint64_t max)</div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l00420">roaring.h:420</a></div></div>
</div><!-- fragment --><p>You should be aware that a convention bitset (<code>bitset_t *</code>) may use much more memory than a Roaring bitmap in some cases. You should run benchmarks to determine whether the conversion to a bitset has performance benefits in your case.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
Example (C++)</h1>
<p>This example assumes that CRoaring has been build and that you are linking against the corresponding library. By default, CRoaring will install its header files in a <code>roaring</code> directory so you may need to replace <code>#include "roaring.hh"</code> by <code>#include &lt;roaring/roaring.hh&gt;</code>. If you are working from the amalgamation script, you may add the line <code>#include "roaring.c"</code> if you are not linking against a CRoaring prebuilt library.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;roaring.hh&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>roaring;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Roaring r1;</div>
<div class="line">    <span class="keywordflow">for</span> (uint32_t i = 100; i &lt; 1000; i++) {</div>
<div class="line">        r1.add(i);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// check whether a value is contained</span></div>
<div class="line">    assert(r1.contains(500));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// compute how many bits there are:</span></div>
<div class="line">    uint32_t cardinality = r1.cardinality();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// if your bitmaps have long runs, you can compress them by calling</span></div>
<div class="line">    <span class="comment">// run_optimize</span></div>
<div class="line">    uint32_t size = r1.getSizeInBytes();</div>
<div class="line">    r1.runOptimize();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// you can enable &quot;copy-on-write&quot; for fast and shallow copies</span></div>
<div class="line">    r1.setCopyOnWrite(<span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    uint32_t compact_size = r1.getSizeInBytes();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;size before run optimize &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; bytes, and after &quot;</span></div>
<div class="line">              &lt;&lt; compact_size &lt;&lt; <span class="stringliteral">&quot; bytes.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a new bitmap with varargs</span></div>
<div class="line">    Roaring r2 = Roaring::bitmapOf(5, 1, 2, 3, 5, 6);</div>
<div class="line"> </div>
<div class="line">    r2.printf();</div>
<div class="line">    printf(<span class="stringliteral">&quot;\n&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// create a new bitmap with initializer list</span></div>
<div class="line">    Roaring r2i = Roaring::bitmapOfList({1, 2, 3, 5, 6});</div>
<div class="line"> </div>
<div class="line">    assert(r2i == r2);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can also create a bitmap from a pointer to 32-bit integers</span></div>
<div class="line">    <span class="keyword">const</span> uint32_t values[] = {2, 3, 4};</div>
<div class="line">    Roaring r3(3, values);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can also go in reverse and go from arrays to bitmaps</span></div>
<div class="line">    uint64_t card1 = r1.cardinality();</div>
<div class="line">    uint32_t *arr1 = <span class="keyword">new</span> uint32_t[card1];</div>
<div class="line">    r1.toUint32Array(arr1);</div>
<div class="line">    Roaring r1f(card1, arr1);</div>
<div class="line">    <span class="keyword">delete</span>[] arr1;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// bitmaps shall be equal</span></div>
<div class="line">    assert(r1 == r1f);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can copy and compare bitmaps</span></div>
<div class="line">    Roaring z(r3);</div>
<div class="line">    assert(r3 == z);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can compute union two-by-two</span></div>
<div class="line">    Roaring r1_2_3 = r1 | r2;</div>
<div class="line">    r1_2_3 |= r3;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can compute a big union</span></div>
<div class="line">    <span class="keyword">const</span> Roaring *allmybitmaps[] = {&amp;r1, &amp;r2, &amp;r3};</div>
<div class="line">    Roaring bigunion = Roaring::fastunion(3, allmybitmaps);</div>
<div class="line">    assert(r1_2_3 == bigunion);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can compute intersection two-by-two</span></div>
<div class="line">    Roaring i1_2 = r1 &amp; r2;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can write a bitmap to a pointer and recover it later</span></div>
<div class="line">    uint32_t expectedsize = r1.getSizeInBytes();</div>
<div class="line">    <span class="keywordtype">char</span> *serializedbytes = <span class="keyword">new</span> <span class="keywordtype">char</span>[expectedsize];</div>
<div class="line">    r1.write(serializedbytes);</div>
<div class="line">    <span class="comment">// readSafe will not overflow, but the resulting bitmap</span></div>
<div class="line">    <span class="comment">// is only valid and usable if the input follows the</span></div>
<div class="line">    <span class="comment">// Roaring specification: https://github.com/RoaringBitmap/RoaringFormatSpec/</span></div>
<div class="line">    Roaring t = Roaring::readSafe(serializedbytes, expectedsize);</div>
<div class="line">    assert(r1 == t);</div>
<div class="line">    <span class="keyword">delete</span>[] serializedbytes;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can iterate over all values using custom functions</span></div>
<div class="line">    uint32_t counter = 0;</div>
<div class="line">    r1.iterate(</div>
<div class="line">        [](uint32_t value, <span class="keywordtype">void</span> *param) {</div>
<div class="line">            *(uint32_t *)param += value;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        },</div>
<div class="line">        &amp;counter);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can also iterate the C++ way</span></div>
<div class="line">    counter = 0;</div>
<div class="line">    <span class="keywordflow">for</span> (Roaring::const_iterator i = t.begin(); i != t.end(); i++) {</div>
<div class="line">        ++counter;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// counter == t.cardinality()</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// we can move iterators to skip values</span></div>
<div class="line">    <span class="keyword">const</span> uint32_t manyvalues[] = {2, 3, 4, 7, 8};</div>
<div class="line">    Roaring rogue(5, manyvalues);</div>
<div class="line">    Roaring::const_iterator j = rogue.begin();</div>
<div class="line">    j.equalorlarger(4);  <span class="comment">// *j == 4</span></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md35"></a>
Building with cmake (Linux and macOS, Visual Studio or OpenHarmony users should see below)</h1>
<p>CRoaring follows the standard cmake workflow. Starting from the root directory of the project (CRoaring), you can do:</p>
<div class="fragment"><div class="line">mkdir -p build</div>
<div class="line">cd build</div>
<div class="line">cmake ..</div>
<div class="line">cmake --build .</div>
<div class="line"># follow by &#39;ctest&#39; if you want to test.</div>
<div class="line"># you can also type &#39;make install&#39; to install the library on your system</div>
<div class="line"># C header files typically get installed to /usr/local/include/roaring</div>
<div class="line"># whereas C++ header files get installed to /usr/local/include/roaring</div>
</div><!-- fragment --><p> (You can replace the <code>build</code> directory with any other directory name.) By default all tests are built on all platforms, to skip building and running tests add <code>-DENABLE_ROARING_TESTS=OFF</code> to the command line.</p>
<p>As with all <code>cmake</code> projects, you can specify the compilers you wish to use by adding (for example) <code>-DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++</code> to the <code>cmake</code> command line.</p>
<p>If you are using clang or gcc and you know your target architecture, you can set the architecture by specifying <code>-DROARING_ARCH=arch</code>. For example, if you have many server but the oldest server is running the Intel <code>haswell</code> architecture, you can specify -<code>DROARING_ARCH=haswell</code>. In such cases, the produced binary will be optimized for processors having the characteristics of a haswell process and may not run on older architectures. You can find out the list of valid architecture values by typing <code>man gcc</code>.</p>
<div class="fragment"><div class="line">mkdir -p build_haswell</div>
<div class="line">cd build_haswell</div>
<div class="line">cmake -DROARING_ARCH=haswell ..</div>
<div class="line">cmake --build .</div>
</div><!-- fragment --><p>For a debug release, starting from the root directory of the project (CRoaring), try</p>
<div class="fragment"><div class="line">mkdir -p debug</div>
<div class="line">cd debug</div>
<div class="line">cmake -DCMAKE_BUILD_TYPE=Debug -DROARING_SANITIZE=ON ..</div>
<div class="line">ctest</div>
</div><!-- fragment --><p>To check that your code abides by the style convention (make sure that <code>clang-format</code> is installed):</p>
<div class="fragment"><div class="line">./tools/clang-format-check.sh</div>
</div><!-- fragment --><p>To reformat your code according to the style convention (make sure that <code>clang-format</code> is installed):</p>
<div class="fragment"><div class="line">./tools/clang-format.sh</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md36"></a>
Building (Visual Studio under Windows)</h1>
<p>We are assuming that you have a common Windows PC with at least Visual Studio 2015, and an x64 processor.</p>
<p>To build with at least Visual Studio 2015 from the command line:</p><ul>
<li>Grab the CRoaring code from GitHub, e.g., by cloning it using <a href="https://desktop.github.com/">GitHub Desktop</a>.</li>
<li>Install <a href="https://cmake.org/download/">CMake</a>. When you install it, make sure to ask that <code>cmake</code> be made available from the command line.</li>
<li>Create a subdirectory within CRoaring, such as <code>VisualStudio</code>.</li>
<li>Using a shell, go to this newly created directory. For example, within GitHub Desktop, you can right-click on  <code>CRoaring</code> in your GitHub repository list, and select <code>Open in Git Shell</code>, then type <code>cd VisualStudio</code> in the newly created shell.</li>
<li>Type <code>cmake -DCMAKE_GENERATOR_PLATFORM=x64 ..</code> in the shell while in the <code>VisualStudio</code> repository. (Alternatively, if you want to build a static library, you may use the command line <code>cmake -DCMAKE_GENERATOR_PLATFORM=x64 -DROARING_BUILD_STATIC=ON ..</code>.)</li>
<li>This last command created a Visual Studio solution file in the newly created directory (e.g., <code>RoaringBitmap.sln</code>). Open this file in Visual Studio. You should now be able to build the project and run the tests. For example, in the <code>Solution Explorer</code> window (available from the <code>View</code> menu), right-click <code>ALL_BUILD</code> and select <code>Build</code>. To test the code, still in the <code>Solution Explorer</code> window, select <code>RUN_TESTS</code> and select <code>Build</code>.</li>
</ul>
<p>To build with at least Visual Studio 2017 directly in the IDE:</p><ul>
<li>Grab the CRoaring code from GitHub, e.g., by cloning it using <a href="https://desktop.github.com/">GitHub Desktop</a>.</li>
<li>Select the <code>Visual C++ tools for CMake</code> optional component when installing the C++ Development Workload within Visual Studio.</li>
<li>Within Visual Studio use <code>File &gt; Open &gt; Folder...</code> to open the CRoaring folder.</li>
<li>Right click on <code>CMakeLists.txt</code> in the parent directory within <code>Solution Explorer</code> and select <code>Build</code> to build the project.</li>
<li>For testing, in the Standard toolbar, drop the <code>Select Startup Item...</code> menu and choose one of the tests. Run the test by pressing the button to the left of the dropdown.</li>
</ul>
<p>We have optimizations specific to AVX2 and AVX-512 in the code, and they are turned dynamically based on the detected hardware at runtime.</p>
<h2><a class="anchor" id="autotoc_md37"></a>
Usage (Using &lt;tt&gt;conan&lt;/tt&gt;)</h2>
<p>You can install pre-built binaries for <code>roaring</code> or build it from source using <a href="https://conan.io/">Conan</a>. Use the following command to install latest version:</p>
<div class="fragment"><div class="line">conan install --requires=&quot;roaring/[*]&quot; --build=missing</div>
</div><!-- fragment --><p>For detailed instructions on how to use Conan, please refer to the <a href="https://docs.conan.io/2/">Conan documentation</a>.</p>
<p>The <code>roaring</code> Conan recipe is kept up to date by Conan maintainers and community contributors. If the version is out of date, please <a href="https://github.com/conan-io/conan-center-index">create an issue or pull request</a> on the ConanCenterIndex repository.</p>
<h2><a class="anchor" id="autotoc_md38"></a>
Usage (Using &lt;tt&gt;vcpkg&lt;/tt&gt; on Windows, Linux and macOS)</h2>
<p><a href="https://github.com/Microsoft/vcpkg">vcpkg</a> users on Windows, Linux and macOS can download and install <code>roaring</code> with one single command from their favorite shell.</p>
<p>On Linux and macOS:</p>
<div class="fragment"><div class="line">$ ./vcpkg install roaring</div>
</div><!-- fragment --><p>will build and install <code>roaring</code> as a static library.</p>
<p>On Windows (64-bit):</p>
<div class="fragment"><div class="line">.\vcpkg.exe install roaring:x64-windows</div>
</div><!-- fragment --><p>will build and install <code>roaring</code> as a shared library.</p>
<div class="fragment"><div class="line">.\vcpkg.exe install roaring:x64-windows-static</div>
</div><!-- fragment --><p>will build and install <code>roaring</code> as a static library.</p>
<p>These commands will also print out instructions on how to use the library from MSBuild or CMake-based projects.</p>
<p>If you find the version of <code>roaring</code> shipped with <code>vcpkg</code> is out-of-date, feel free to report it to <code>vcpkg</code> community either by submiting an issue or by creating a PR.</p>
<h1><a class="anchor" id="autotoc_md39"></a>
Building (OpenHarmony)</h1>
<p>To build with OpenHarmony SDK please see the <a href="https://gitcode.com/openharmony-sig/tpc_c_cplusplus/blob/master/Cross-Compilation Guide for Open-Source Third-Party Libraries in OpenHarmony_en.md">OpenHarmony Cross Compile Guide</a></p>
<h1><a class="anchor" id="autotoc_md40"></a>
SIMD-related throttling</h1>
<p>Our AVX2 code does not use floating-point numbers or multiplications, so it is not subject to turbo frequency throttling on many-core Intel processors.</p>
<p>Our AVX-512 code is only enabled on recent hardware (Intel Ice Lake or better and AMD Zen 4) where SIMD-specific frequency throttling is not observed.</p>
<h1><a class="anchor" id="autotoc_md41"></a>
Thread safety</h1>
<p>Like, for example, STL containers, the CRoaring library has no built-in thread support. Thus whenever you modify a bitmap in one thread, it is unsafe to query it in others. However, you can safely copy a bitmap and use both copies in concurrently.</p>
<p>If you use "copy-on-write" (default to disabled), then you should pass copies to the different threads. They will create shared containers, and for shared containers, we use reference counting with an atomic counter.</p>
<p>To summarize:</p><ul>
<li>If you do not use copy-on-write, you can access concurrent the same bitmap safely as long as you do not modify it. If you plan on modifying it, you should pass different copies to the different threads.</li>
<li>If you use copy-on-write, you should always pass copies to the different threads. The copies and then lightweight (shared containers).</li>
</ul>
<p>Thus the following pattern where you copy bitmaps and pass them to different threads is safe with or without COW:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="dc/d56/roaring_8h.html#a84bd77c991d7520ab336433b3dff4cf5">roaring_bitmap_set_copy_on_write</a>(r1, <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="dc/d56/roaring_8h.html#a84bd77c991d7520ab336433b3dff4cf5">roaring_bitmap_set_copy_on_write</a>(r2, <span class="keyword">true</span>);</div>
<div class="line"><a class="code hl_function" href="dc/d56/roaring_8h.html#a84bd77c991d7520ab336433b3dff4cf5">roaring_bitmap_set_copy_on_write</a>(r3, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> * r1a = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r1);</div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> * r1b = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r1);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> * r2a = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r2);</div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> * r2b = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r2);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> * r3a = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r3);</div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> * r3b = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(r3);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *rarray1[3] = {r1a, r2a, r3a};</div>
<div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *rarray2[3] = {r1b, r2b, r3b};</div>
<div class="line">std::thread thread1(run, rarray1);</div>
<div class="line">std::thread thread2(run, rarray2);</div>
<div class="ttc" id="aroaring_8h_html_a84bd77c991d7520ab336433b3dff4cf5"><div class="ttname"><a href="dc/d56/roaring_8h.html#a84bd77c991d7520ab336433b3dff4cf5">roaring_bitmap_set_copy_on_write</a></div><div class="ttdeci">void roaring_bitmap_set_copy_on_write(roaring_bitmap_t *r, bool cow)</div><div class="ttdef"><b>Definition</b> <a href="dc/d56/roaring_8h_source.html#l00104">roaring.h:104</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md42"></a>
How to best aggregate bitmaps?</h1>
<p>Suppose you want to compute the union (OR) of many bitmaps. How do you proceed? There are many different strategies.</p>
<p>You can use <code>roaring_bitmap_or_many(bitmapcount, bitmaps)</code> or <code>roaring_bitmap_or_many_heap(bitmapcount, bitmaps)</code> or you may even roll your own aggregation:</p>
<div class="fragment"><div class="line"><a class="code hl_struct" href="dd/d7a/structroaring__bitmap__s.html">roaring_bitmap_t</a> *answer = <a class="code hl_function" href="dc/d56/roaring_8h.html#a30850dcaa92db1490643ccdf89856b27">roaring_bitmap_copy</a>(bitmaps[0]);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 1; i &lt; bitmapcount; i++) {</div>
<div class="line">  <a class="code hl_function" href="dc/d56/roaring_8h.html#aa76a1e1fb5d1dcf88931aa7cd3961d1f">roaring_bitmap_or_inplace</a>(answer, bitmaps[i]);</div>
<div class="line">}</div>
</div><!-- fragment --><p>All of them will work but they have different performance characteristics. The <code>roaring_bitmap_or_many_heap</code> should probably only be used if, after benchmarking, you find that it is faster by a good margin: it uses more memory.</p>
<p>The <code>roaring_bitmap_or_many</code> is meant as a good default. It works by trying to delay work as much as possible. However, because it delays computations, it also does not optimize the format as the computation runs. It might thus fail to see some useful pattern in the data such as long consecutive values.</p>
<p>The approach based on repeated calls to <code>roaring_bitmap_or_inplace</code> is also fine, and might even be faster in some cases. You can expect it to be faster if, after a few calls, you get long sequences of consecutive values in the answer. That is, if the final answer is all integers in the range [0,1000000), and this is apparent quickly, then the later <code>roaring_bitmap_or_inplace</code> will be very fast.</p>
<p>You should benchmark these alternatives on your own data to decide what is best.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
Wrappers for Roaring Bitmaps</h1>
<p>This page lists several community-contributed wrappers for the Roaring Bitmap library, enabling its use in various programming languages and environments.</p>
<h2><a class="anchor" id="autotoc_md44"></a>
Python</h2>
<p>Tom Cornebize developed a Python wrapper, <b>PyRoaringBitMap</b>, which can be found at <a href="https://github.com/Ezibenroc/PyRoaringBitMap">https://github.com/Ezibenroc/PyRoaringBitMap</a>.</p>
<p>Installation is straightforward using pip:</p>
<div class="fragment"><div class="line">pip install pyroaring</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md45"></a>
JavaScript (Node.js)</h2>
<p>Salvatore Previti created a Node.js wrapper, <b>roaring-node</b>, available at <a href="https://github.com/SalvatorePreviti/roaring-node">https://github.com/SalvatorePreviti/roaring-node</a>.</p>
<p>You can install it via npm with the following command:</p>
<div class="fragment"><div class="line">npm install roaring</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md46"></a>
Swift</h2>
<p>Jérémie Piotte authored the <a href="https://github.com/RoaringBitmap/SwiftRoaring">Swift wrapper</a>.</p>
<h2><a class="anchor" id="autotoc_md47"></a>
C</h2>
<p>There is a C# wrapper, <b>CRoaring.Net</b>, located at <a href="https://github.com/k-wojcik/Roaring.Net">https://github.com/k-wojcik/Roaring.Net</a>. This wrapper is compatible with Windows and Linux on x64 processors.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
Go (Golang)</h2>
<p>A Go wrapper is available at the official RoaringBitmap GitHub organization: <a href="https://github.com/RoaringBitmap/gocroaring">https://github.com/RoaringBitmap/gocroaring</a>.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
Rust</h2>
<p>Saulius Grigaliunas developed a Rust wrapper, <b>croaring-rs</b>, which can be found at <a href="https://github.com/saulius/croaring-rs">https://github.com/saulius/croaring-rs</a>.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
D</h2>
<p>Yuce Tekol created a D wrapper, <b>droaring</b>, available at <a href="https://github.com/yuce/droaring">https://github.com/yuce/droaring</a>.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
Redis Module</h2>
<p>Antonio Guilherme Ferreira Viggiano wrote a Redis Module integrating Roaring Bitmaps, available at <a href="https://github.com/aviggiano/redis-roaring">https://github.com/aviggiano/redis-roaring</a>.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
Zig</h2>
<p>Justin Whear contributed a Zig wrapper, located at <a href="https://github.com/jwhear/roaring-zig">https://github.com/jwhear/roaring-zig</a>.</p>
<h1><a class="anchor" id="autotoc_md53"></a>
Mailing list/discussion group</h1>
<p><a href="https://groups.google.com/forum/#!forum/roaring-bitmaps">https://groups.google.com/forum/#!forum/roaring-bitmaps</a></p>
<h1><a class="anchor" id="autotoc_md54"></a>
Contributing</h1>
<p>When contributing a change to the project, please run <code>tools/run-clangcldocker.sh</code> after making any changes. A github action runs on all PRs to ensure formatting is consistent with this.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
References about Roaring</h1>
<ul>
<li>Daniel Lemire, Owen Kaser, Nathan Kurz, Luca Deri, Chris O'Hara, François Saint-Jacques, Gregory Ssi-Yan-Kai, Roaring Bitmaps: Implementation of an Optimized Software Library, Software: Practice and Experience Volume 48, Issue 4 April 2018 Pages 867-895 <a href="https://arxiv.org/abs/1709.07821">arXiv:1709.07821</a></li>
<li>Samy Chambi, Daniel Lemire, Owen Kaser, Robert Godin, Better bitmap performance with Roaring bitmaps, Software: Practice and Experience Volume 46, Issue 5, pages 709–719, May 2016 <a href="http://arxiv.org/abs/1402.6407">arXiv:1402.6407</a></li>
<li>Daniel Lemire, Gregory Ssi-Yan-Kai, Owen Kaser, Consistently faster and smaller compressed bitmaps with Roaring, Software: Practice and Experience Volume 46, Issue 11, pages 1547-1569, November 2016 <a href="http://arxiv.org/abs/1603.06549">arXiv:1603.06549</a></li>
<li>Samy Chambi, Daniel Lemire, Robert Godin, Kamel Boukhalfa, Charles Allen, Fangjin Yang, Optimizing Druid with Roaring bitmaps, IDEAS 2016, 2016. <a href="http://r-libre.teluq.ca/950/">http://r-libre.teluq.ca/950/</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
